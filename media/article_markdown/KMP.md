# KMP算法

一般情况我们在string里寻找子串就是暴力枚举，对比，这样的时间复杂程度最大是o（mn）（m，n分别为母串与子串的长度），而KMP算法可以将时间复杂度降到O（m）

### KMP算法

利用字串的字串对称性进行匹配，生成一个失效数组，即p[j]指，在a[i]=b[j],但是a[i+1] != b[j]的时候j应当回到哪个位置，则利用的是子串自己的一个对称性，所以，可以遇见，这个p数组一定是一个可以用动态规划来写的函数

p[j] = 1.j (j>0 &&data[p[j]+1] != data[i])

​	  2.j<0 p[i] = -1

​	 3.(j>0 && data[p[j]+1] == data[i])p[i] = p[j]+1

在查找的过程中，如果-1出现了一次还是不能匹配，就只能j不懂，开始++i

模拟动态内存储备：详见python中的数组中放元祖，你用数组读也可以，用链接读也可以。

关于中缀式转换为后缀是的方法

1.暴力“取消”运算符号的优先级，然后把运算符号右移一个括号，消除所有括号

2.使用栈操作和输出

a.左括号入栈，知道遇到右括号，括号范围完全出栈

b.读到下一个想入栈的符号比现栈顶的运算等级低，则出栈输出。

c.读到数字直接输出

d.如果读入的是乘方，必定入栈，后面是除了其他运算以外的运算，则出栈输出



### 关于用栈模拟递归的想法

基于栈这种越在栈底越大，越在栈顶越小的这样的设计构造，相当于是在用出栈入栈的顺序体现深度优先，递归的问题一定是深度优先，因而必然可以用这样的方法去做。则，关于深度优先的问题都已用栈去处理，但优势到底有什么呢。

基友告诉我，不如不写，反正系统自己也这么处理。

从某种角度上来讲，我觉得栈比一般递归好在于，有时候他能帮你储存一些结果。





